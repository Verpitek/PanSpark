function L(f,M){let y=M.arguments[0],c=M.arguments[1];f.setMemory(y.value,c)}function Q(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(f.fetchMemory(y)+f.fetchMemory(c),m)}function B(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(f.fetchMemory(y)-f.fetchMemory(c),m)}function G(f,M){let y=M.arguments[0];if(y.type==0)f.outputBuffer.push(y.value);if(y.type==1)f.outputBuffer.push(f.fetchMemory(y));if(y.type==2)f.outputBuffer.push(f.fetchMemory(y))}function k(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2],h;switch(c.type){case 3:h=f.fetchMemory(y)==f.fetchMemory(m);break;case 4:h=f.fetchMemory(y)!=f.fetchMemory(m);break;case 5:h=f.fetchMemory(y)<f.fetchMemory(m);break;case 6:h=f.fetchMemory(y)>f.fetchMemory(m);break;case 7:h=f.fetchMemory(y)<=f.fetchMemory(m);break;case 8:h=f.fetchMemory(y)>=f.fetchMemory(m);break;default:h=!1}return h}function S(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(f.fetchMemory(y)*f.fetchMemory(c),m)}function U(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(f.fetchMemory(y)/f.fetchMemory(c),m)}function q(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(f.fetchMemory(y)%f.fetchMemory(c),m)}function w(f,M){let y=M.arguments[0],c=M.arguments[1];f.setMemory(Math.sqrt(f.fetchMemory(y)),c)}function N(f,M){let y=M.arguments[0],c=M.arguments[1],m=M.arguments[2];f.setMemory(Math.pow(f.fetchMemory(y),f.fetchMemory(c)),m)}function Y(f,M){let y=M.arguments[0],c=M.arguments[1];f.setMemory(Math.abs(f.fetchMemory(y)),c)}function g(f,M){let y=M.arguments[0],c=f.fetchMemory(y),m=M.arguments[1],h=f.fetchMemory(m),x=M.arguments[2];if(c<h)f.setMemory(c,x);else f.setMemory(h,x)}function j(f,M){let y=M.arguments[0],c=f.fetchMemory(y),m=M.arguments[1],h=f.fetchMemory(m),x=M.arguments[2];if(c>h)f.setMemory(c,x);else f.setMemory(h,x)}function H(f,M){let y=M.arguments[0],c=f.fetchMemory(y);f.setMemory(c+1,y)}function K(f,M){let y=M.arguments[0],c=f.fetchMemory(y);f.setMemory(c-1,y)}function W(f,M){let y=f.fetchMemory(M.arguments[0]),c=f.fetchMemory(M.arguments[1]),m=M.arguments[2],h=Math.min(y,c),x=Math.max(y,c),X=Math.floor(Math.random()*(x-h+1))+h;f.setMemory(X,m)}var Z;((V)=>{V[V.SET=0]="SET";V[V.ADD=1]="ADD";V[V.SUB=2]="SUB";V[V.PRINT=3]="PRINT";V[V.JUMP=4]="JUMP";V[V.POINT=5]="POINT";V[V.IF=6]="IF";V[V.MUL=7]="MUL";V[V.DIV=8]="DIV";V[V.MOD=9]="MOD";V[V.SQRT=10]="SQRT";V[V.POW=11]="POW";V[V.ABS=12]="ABS";V[V.MIN=13]="MIN";V[V.MAX=14]="MAX";V[V.INC=15]="INC";V[V.DEC=16]="DEC";V[V.RNG=17]="RNG";V[V.NOP=18]="NOP";V[V.HALT=19]="HALT";V[V.UNTIL=20]="UNTIL";V[V.CALL=21]="CALL";V[V.RET=22]="RET"})(Z||={});var R;((D)=>{D[D.LITERAL=0]="LITERAL";D[D.REGISTER=1]="REGISTER";D[D.MEMORY=2]="MEMORY";D[D.EQUAL=3]="EQUAL";D[D.NOTEQUAL=4]="NOTEQUAL";D[D.LESS=5]="LESS";D[D.GREATER=6]="GREATER";D[D.LESSEQUAL=7]="LESSEQUAL";D[D.GREATEQUAL=8]="GREATEQUAL";D[D.LABEL=9]="LABEL"})(R||={});function _(f){if(f.startsWith("r"))return{type:1,value:parseInt(f.slice(1))};else if(f.startsWith("x"))return{type:2,value:parseInt(f.slice(1))};else if(f=="==")return{type:3,value:0};else if(f=="!=")return{type:4,value:0};else if(f=="<")return{type:5,value:0};else if(f==">")return{type:6,value:0};else if(f=="<=")return{type:7,value:0};else if(f==">=")return{type:8,value:0};else return{type:0,value:parseInt(f)}}function E(f,M,y){let c=M.split(" ").splice(1),m=[];for(let h of c)if(h!=">>")m.push(_(h));return{operation:f,arguments:m,line:y}}class ${outputBuffer=[];instructions=[];activeInstructionPos=0;registerMemoryLimit=0;machineMemoryLimit=0;registerMemory=[];machineMemory=[];runFastFlag=!1;constructor(f,M){this.registerMemoryLimit=f,this.machineMemoryLimit=M,this.registerMemory=Array(this.registerMemoryLimit).fill(0),this.machineMemory=Array(this.machineMemoryLimit).fill(0)}saveState(){let f=this.activeInstructionPos.toString(),M=this.registerMemory.slice(0,this.findLastNonZeroIndex(this.registerMemory)+1).join(","),y=this.machineMemory.slice(0,this.findLastNonZeroIndex(this.machineMemory)+1).join(","),c=this.outputBuffer.join(","),m=JSON.stringify(this.instructions);return`${f}|${M}|${y}|${c}|${m}`}loadState(f){let M=0,y=0;for(let h=0;h<f.length&&M<4;h++)if(f[h]==="|"){if(M++,M===4){y=h;break}}let c=f.substring(0,y).split("|"),m=f.substring(y+1);if(c.length<4)throw Error("Invalid savestate format");if(this.activeInstructionPos=parseInt(c[0]),this.registerMemory=[],c[1]){let h=c[1].split(",").map((x)=>parseInt(x));for(let x=0;x<h.length;x++)this.registerMemory[x]=h[x]}for(let h=this.registerMemory.length;h<this.registerMemoryLimit;h++)this.registerMemory[h]=0;if(this.machineMemory=[],c[2]){let h=c[2].split(",").map((x)=>parseInt(x));for(let x=0;x<h.length;x++)this.machineMemory[x]=h[x]}for(let h=this.machineMemory.length;h<this.machineMemoryLimit;h++)this.machineMemory[h]=0;if(this.outputBuffer=[],c[3])this.outputBuffer=c[3].split(",").map((h)=>parseInt(h));if(m)this.instructions=JSON.parse(m)}findLastNonZeroIndex(f){for(let M=f.length-1;M>=0;M--)if(f[M]!==0&&f[M]!==void 0)return M;return-1}setMemory(f,M){if(M.type==0)throw Error("memory destination cannot be a LITERAL! at line: "+(this.activeInstructionPos+1));else if(M.type==1){if(M.value>=this.registerMemoryLimit||M.value<0)throw Error("outside register memory bounds!");this.registerMemory[M.value]=f}else if(M.type==2){if(M.value>=this.machineMemoryLimit||M.value<0)throw Error("outside machine memory bounds!");this.machineMemory[M.value]=f}else throw Error("illegal operation! at line: "+(this.activeInstructionPos+1))}fetchMemory(f){if(f.type==0)return f.value;else if(f.type==1){if(f.value>=this.registerMemoryLimit||f.value<0)throw Error("outside register memory bounds!");return this.registerMemory[f.value]}else if(f.type==2){if(f.value>=this.machineMemoryLimit||f.value<0)throw Error("outside machine memory bounds!");return this.machineMemory[f.value]}else throw Error("empty or illegal memory fetch! at line: "+(this.activeInstructionPos+1))}*compile(f){let M=f.split(`
`),y=[];for(let m in M){let h=M[m].split(" ")[0];if(h==""||h.startsWith("//"))continue;else y.push(M[m])}M=y;let c=new Map;for(let m in M){let h=M[m].split(" ");if(h[0]=="POINT")c[h[1]]=m}for(let m in M){let h=null,x=M[m].split(" ")[0];switch(x){case"SET":h=E(0,M[m],parseInt(m));break;case"ADD":h=E(1,M[m],parseInt(m));break;case"SUB":h=E(2,M[m],parseInt(m));break;case"PRINT":h=E(3,M[m],parseInt(m));break;case"JUMP":h=E(4,M[m].replace(M[m].split(" ")[1],c[M[m].split(" ")[1]]),parseInt(m));break;case"POINT":h=E(5,M[m].replace(M[m].split(" ")[1],c[M[m].split(" ")[1]]),parseInt(m));break;case"IF":h=E(6,M[m].replace(M[m].split(" ")[5],c[M[m].split(" ")[5]]),parseInt(m));break;case"MUL":h=E(7,M[m],parseInt(m));break;case"DIV":h=E(8,M[m],parseInt(m));break;case"MOD":h=E(9,M[m],parseInt(m));break;case"SQRT":h=E(10,M[m],parseInt(m));break;case"POW":h=E(11,M[m],parseInt(m));break;case"ABS":h=E(12,M[m],parseInt(m));break;case"MIN":h=E(13,M[m],parseInt(m));break;case"MAX":h=E(14,M[m],parseInt(m));break;case"INC":h=E(15,M[m],parseInt(m));break;case"DEC":h=E(16,M[m],parseInt(m));break;case"RNG":h=E(17,M[m],parseInt(m));break;case"NOP":h=E(18,M[m],parseInt(m));break;case"HALT":h=E(19,M[m],parseInt(m));break;case"UNTIL":h=E(20,M[m],parseInt(m));break;default:console.log("unknown OpCode: "+x);continue}this.instructions.push(h),yield h}}*run(){while(this.activeInstructionPos<this.instructions.length){let f=!1;this.outputBuffer=[];let M=this.instructions[this.activeInstructionPos];switch(M.operation){case 0:L(this,M);break;case 3:G(this,M);break;case 1:Q(this,M);break;case 2:B(this,M);break;case 4:this.activeInstructionPos=M.arguments[0].value,f=!0;break;case 5:break;case 6:if(k(this,M)==!0)this.activeInstructionPos=M.arguments[3].value,f=!0;break;case 19:return;case 18:break;case 7:S(this,M);break;case 8:U(this,M);break;case 9:q(this,M);break;case 10:w(this,M);break;case 11:N(this,M);break;case 12:Y(this,M);break;case 13:g(this,M);break;case 14:j(this,M);break;case 15:H(this,M);break;case 16:K(this,M);break;case 17:W(this,M);break;case 20:if(k(this,M)!=!0)f=!0;break;default:throw Error("Unknown OpCode: "+M.operation)}if(!this.runFastFlag)yield;if(!f)this.activeInstructionPos++}}}export{$ as VM,Z as OpCode,R as ArgType};
